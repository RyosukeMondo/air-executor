{
  "id": "snapshot_1759336600961_duix5wxgx",
  "approvalId": "approval_1759336600959_fdt34h0mb",
  "approvalTitle": "Tech Stack Documentation",
  "version": 1,
  "timestamp": "2025-10-01T16:36:40.961Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Technology Stack\n\n## Project Type\n\nAir-Executor is a workflow orchestration system with two implementation paths:\n1. **Airflow-based**: DAG-driven orchestration using Apache Airflow with KubernetesExecutor\n2. **Prefect-based**: Python-native workflow orchestration using Prefect with Work Pools\n\nBoth implementations share common patterns but differ in deployment infrastructure and execution models.\n\n## Core Technologies\n\n### Primary Language(s)\n- **Language**: Python 3.11+\n- **Runtime**: CPython 3.11 or higher\n- **Package Manager**: pip with requirements.txt\n- **Build Tools**: make for common operations (install, test, run)\n\n### Key Dependencies/Libraries\n\n**Airflow Implementation:**\n- **Apache Airflow 2.8+**: Workflow orchestration and scheduling\n- **Kubernetes Python Client**: Pod management and status monitoring\n- **PostgreSQL Driver (psycopg2)**: Metadata database connectivity\n\n**Prefect Implementation:**\n- **Prefect 2.14+**: Dynamic workflow orchestration\n- **Docker SDK**: Container-based task execution\n- **httpx**: Async HTTP client for Prefect API communication\n\n**Shared Dependencies:**\n- **Claude Code CLI**: AI-assisted task execution (wrapper integration)\n- **pydantic**: Data validation and settings management\n- **structlog**: Structured logging for observability\n- **pytest**: Testing framework with pytest-asyncio\n- **click**: CLI interface for job management commands\n\n### Application Architecture\n\n**Control Plane Architecture:**\n- **Job Manager**: Polling loop that monitors job status and spawns task runners\n- **Task Runner**: Single-task execution wrapper around Claude Code CLI\n- **Job Store**: File-based or database-backed job state persistence\n\n**Airflow Architecture:**\n- Scheduler acts as MCP (Master Control Program)\n- KubernetesExecutor creates ephemeral Pods per task\n- Dynamic Task Mapping for runtime sub-task generation\n- DAGs define job structure with expand() for dynamic tasks\n\n**Prefect Architecture:**\n- Prefect API Server acts as control plane\n- Work Pools with Process/Docker workers\n- Flow-as-orchestrator pattern with subflow submissions\n- --run-once workers for ephemeral execution model\n\n### Data Storage\n\n- **Primary Storage**:\n  - Airflow: PostgreSQL for metadata, Redis for broker (optional)\n  - Prefect: SQLite (dev) / PostgreSQL (prod) for Prefect API\n  - Job State: JSON files in `.air-executor/jobs/` directory\n- **Caching**: In-memory job status cache with file-based persistence\n- **Data Formats**: JSON for job definitions, YAML for configuration, structured logs in JSON\n\n### External Integrations\n\n- **Kubernetes API**: Pod lifecycle management (Airflow implementation)\n- **Docker Engine API**: Container execution (Prefect implementation)\n- **Claude Code CLI**: Task execution subprocess integration\n- **Protocols**: HTTP/REST for Prefect API, Kubernetes API via Python client\n- **Authentication**: Kubernetes RBAC, Prefect API keys, file-based job access control\n\n### Monitoring & Dashboard Technologies\n\n**MVP (CLI-based):**\n- **Dashboard Framework**: Rich terminal UI using `rich` library\n- **Real-time Communication**: Polling-based status checks (5-second interval)\n- **Visualization**: ASCII progress bars, colored status indicators\n- **State Management**: File system as source of truth for job state\n\n**Future (Web Dashboard):**\n- Dashboard framework TBD (React, Vue, or Streamlit candidates)\n- WebSocket for real-time updates\n- Chart.js or D3 for visualization\n- Prefect/Airflow native UIs as starting point\n\n## Development Environment\n\n### Build & Development Tools\n- **Build System**: Makefile for common tasks (make install, make test, make dev)\n- **Package Management**: pip with virtual environment (venv)\n- **Development Workflow**: Hot reload for job manager (watchdog), manual restart for task runners\n- **Dependency Management**: pip-tools for requirements.txt generation\n\n### Code Quality Tools\n- **Static Analysis**:\n  - ruff for fast Python linting\n  - mypy for type checking\n  - bandit for security scanning\n- **Formatting**:\n  - black (line length 100)\n  - isort for import sorting\n- **Testing Framework**:\n  - pytest for unit/integration tests\n  - pytest-cov for coverage reporting (>80% target)\n  - pytest-asyncio for async test support\n- **Documentation**:\n  - Sphinx for API documentation\n  - mkdocs for user guides\n\n### Version Control & Collaboration\n- **VCS**: Git\n- **Branching Strategy**: GitHub Flow (feature branches â†’ main)\n- **Code Review Process**:\n  - PR required for all changes\n  - Automated CI checks (linting, tests, type checking)\n  - One approval required before merge\n\n### Dashboard Development (Future)\n- **Live Reload**: TBD based on framework choice\n- **Port Management**: Dynamic port allocation (8080-8100 range)\n- **Multi-Instance Support**: Port-based isolation for concurrent job managers\n\n## Deployment & Distribution\n\n- **Target Platforms**:\n  - Linux (Ubuntu 22.04+, RHEL 8+)\n  - macOS (Monterey+)\n  - Windows (WSL2 required)\n- **Distribution Method**:\n  - PyPI package (pip install air-executor)\n  - Docker images for orchestration platforms\n  - GitHub releases with binaries\n- **Installation Requirements**:\n  - Python 3.11+\n  - Kubernetes cluster (Airflow) or Docker Engine (Prefect)\n  - 2GB RAM minimum, 4GB recommended\n  - Claude Code CLI installed and authenticated\n- **Update Mechanism**: pip upgrade, Docker image tags\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n- Job manager polling interval: 5 seconds (configurable 1-60s)\n- Task runner spawn time: <10 seconds\n- Job status query: <100ms\n- Task queue throughput: 50+ tasks/hour\n- Memory footprint: <100MB for job manager, <500MB per task runner\n\n### Compatibility Requirements\n- **Platform Support**: Linux (primary), macOS (development), Windows WSL2 (limited)\n- **Python Versions**: 3.11, 3.12\n- **Kubernetes**: 1.24+ (for Airflow implementation)\n- **Docker**: 20.10+ (for Prefect implementation)\n- **Standards Compliance**: POSIX compliance for file operations, Kubernetes API v1\n\n### Security & Compliance\n- **Security Requirements**:\n  - No secrets in job definitions\n  - File-based access control for job directories\n  - Kubernetes RBAC for Pod operations\n  - Claude Code CLI authentication inheritance\n- **Compliance Standards**: None (internal tooling)\n- **Threat Model**:\n  - Untrusted code execution in isolated runners\n  - Job definition tampering prevention\n  - Resource exhaustion limits\n\n### Scalability & Reliability\n- **Expected Load**: 10-100 concurrent jobs, 100-1000 tasks per day\n- **Availability Requirements**: 99% uptime for job manager, best-effort for task runners\n- **Growth Projections**: Linear scaling with job count, horizontal scaling via multiple job managers\n\n## Technical Decisions & Rationale\n\n### Decision Log\n\n1. **Dual Implementation (Airflow + Prefect)**:\n   - **Why**: Different infrastructure preferences (Kubernetes vs Docker/native Python)\n   - **Alternatives**: Single implementation would limit adoption\n   - **Trade-offs**: Increased maintenance burden, but broader applicability\n\n2. **File-Based Job State**:\n   - **Why**: Simple, no external dependencies, easy debugging\n   - **Alternatives**: Database (added complexity), Redis (requires server)\n   - **Trade-offs**: Not suitable for distributed scenarios, but adequate for MVP\n\n3. **Polling vs Event-Driven**:\n   - **Why**: Simpler to implement, works with any orchestrator\n   - **Alternatives**: Webhooks, message queues (added complexity)\n   - **Trade-offs**: Higher latency (5s), but predictable and reliable\n\n4. **KubernetesExecutor for Airflow**:\n   - **Why**: Native support for ephemeral, single-task Pods\n   - **Alternatives**: CeleryExecutor (persistent workers, not aligned)\n   - **Trade-offs**: Requires Kubernetes, but perfect architectural fit\n\n5. **Claude Code CLI Wrapper**:\n   - **Why**: Leverage existing AI capabilities without reimplementation\n   - **Alternatives**: Direct API integration (more complex, less flexible)\n   - **Trade-offs**: Dependency on CLI stability, but rapid integration\n\n## Known Limitations\n\n- **Single-Machine Job Manager**: Current implementation doesn't support distributed job management (file-based state)\n  - **Impact**: Limited to single-region, single-instance deployment\n  - **Future**: Database-backed state for multi-instance support\n\n- **No Task Retry Logic**: Failed tasks require manual re-queuing\n  - **Impact**: Reduced resilience for transient failures\n  - **Future**: Configurable retry policies with exponential backoff\n\n- **Limited Observability**: CLI-only monitoring in MVP\n  - **Impact**: Difficult to diagnose issues in production\n  - **Future**: Web dashboard with metrics and trace visualization\n\n- **No Resource Limits**: Task runners can consume unbounded resources\n  - **Impact**: Risk of resource exhaustion\n  - **Future**: Kubernetes resource quotas, cgroup limits for Prefect\n",
  "fileStats": {
    "size": 8870,
    "lines": 221,
    "lastModified": "2025-10-01T16:31:54.549Z"
  },
  "comments": []
}
